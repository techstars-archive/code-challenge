# TechStars Engineering: Fun with Code

**Demo!**
http://techstars.jeffastephens.com

## Build/Deployment Instructions

### Running Locally

Make sure Docker is installed and running, then run

    ./bootstrap-compose-stack.sh

After initializing, the app will be available at http://localhost:3000/

### Deploying to the Cloud

The build scripts are set up for DigitalOcean, and you need an Access Token to
use them. Follow steps 1-2 here: https://docs.docker.com/machine/examples/ocean/

Then, run

    ./create-docker-machine.sh <desiredMachineName>
    eval $(docker-machine env <desiredMachineName>)
    ./bootstrap-compose-stack.sh

The app will be available at the IP address of your droplet (which is the last
thing output by `create-docker-machine.sh`).

When you're done, tear down the DigitalOcean environment:

    ./teardown-compose-stack.sh

### Helpful `docker-machine` commands

* Point your local `docker` CLI at a remote host:

      eval $(docker-machine env <docker-machine name>)

* Point your local `docker` CLI back at your local machine:

      eval $(docker-machine env -u)

## Architecture Decisions

The CRUD part of the app was fairly straightforward, following what I believe are
Rails best practices. I generated models, migrations, and controllers using
`rails generate` and created the basic REST methods in my controllers.

I chose to use Twitter Bootstrap because it vastly reduces the amount of boilerplate
CSS needed. My application is more or less screenreader accessible, quite
mobile responsive, and looks decent without much work from me. I realize I did
not write much CSS as part of this submission, but I'm happy to answer questions
or write some on the spot in the interview.

I chose to use postgres for the database mainly because the Docker documentation
does, making it easier to deploy.

For a "quick & dirty" deployment, I'm using `docker-machine` with `docker-compose`.
Were this a real production app, I would create a Jenkins pipeline to build the
Docker image, push it to AWS ECR, and deploy it in one of a number of ways:

* The Rails app could be deployed via Kubernetes (3+ pods for redundancy), an
autoscaling group in AWS ELB, or running the image in Docker hosts directly in
e.g. DigitalOcean.
* The database servers could be configured in a master-slave arrangement for some
redundancy, but I would probably opt for a managed service like AWS RDS.

## Neat Features

1. The index page shows the first two paragraphs of the description (based on
  newline characters), whereas the company detail page shows the whole thing.
  It would be nice to use a community-created gem to do this more elegantly.
1. Tags are downcased for storage and sorted for display
1. The web app is fully responsive (thanks, Bootstrap)
1. Upon creating the deployed stack, the DB is seeded with some sample data

## TODO

Here are a few things I deferred due to time constraints/because this is a
prototype...

1. Add error messages for invalid Founder submissions. Presence and uniqueness
are validated server-side, but no client error is shown.

1. The button for deleting Founders is annoying because only a ' ' character
inside is a link. Fix this either with some Javascript or by wrapping the link
around the Glyphicon (the link is generated by Rails).

1. Once you delete a Founder, you cannot recreate one with the same name because
of the uniqueness check. It might be that ActiveRecord is flipping a bit to
delete rather than running a `DELETE` query, or it might be something else.

1. Tags are not stored optimally. They should be created with a many-to-many
relationship, most likely with an intermediate DB table associating a
`company_id` to a `tag_id`. Due to time constraints, I just made a one-to-many
association between a Company and its Tags.
